import tabulate
import csv
import argparse
from datetime import datetime
import random
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from matplotlib import cm
import matplotlib.lines as mlines
import string
import matplotlib
import numpy as np

parser = argparse.ArgumentParser(
    description="Convert a csv file generated by process_output.py to a scatter plot input csv."
)
parser.add_argument("input", type=str, help="location of input csv file")
parser.add_argument(
    "--comp-field", type=str
)
parser.add_argument(
    "--comp-values", type=str
)
parser.add_argument(
    "--avg-slowdown", action="store_true"
)

args = parser.parse_args()

methods = args.comp_values.split(",")
output_table_headers = ["Model", "Const", "$\\vardelta$", "$\\varepsilon", "Prop"]
for method in methods:
    output_table_headers.append(method[0].upper() + "Time")
for method in methods:
    output_table_headers.append(method[0].upper() + "Regions")

output_table = []

benchmark_map = {}
model_map = {}
with open(args.input) as csvfile:
    reader = csv.DictReader(csvfile)
    for row in reader:
        if row["Model"].startswith("herman_random_pass"):
            row["Model"] = "hermanspeed"
        elif row["Model"].startswith("herman"):
            row["Model"] = "herman"
        benchmark_id = "-".join([row["Model"], row["Const"], row["Mem"], row["Prop"], row["Region Bound"], row["Epsilon"]])
        if benchmark_id not in benchmark_map:
            benchmark_map[benchmark_id] = []
        benchmark_map[benchmark_id].append(row)
        model_map[row["Model"]] = 1
print(benchmark_map)
for key in benchmark_map:
    benchmarks = benchmark_map[key]
    print(benchmarks)
    assert len(benchmarks) == 2

    benchmark = benchmarks[0]
    propsplit = benchmark["Prop"].split("_")
    prop = ""
    if propsplit[1] == "probability":
        prop += "P"
    elif propsplit[1] == "reward":
        prop += "R"
    if propsplit[2] == "max":
        prop += "$\geq$"
    elif propsplit[2] == "min":
        prop += "$\leq$"
    prop += str(round(float(propsplit[0]), 2))

    def shorten_constants(constants):
        if constants == "N/A":
            return ""
        pairs = [x.split("=") for x in constants.split(" ")]
        return " ".join([x[0][0] + "=" + x[1] for x in pairs if len(x) == 2])

    line = [
        benchmark["Model"],
        shorten_constants(benchmark["Const"]),
        benchmark["Region Bound"],
        benchmark["Epsilon"],
        prop
    ]
    for val in methods:
        for benchmark in benchmarks:
            if benchmark[args.comp_field] == val:
                if benchmark["Time (wall)"] == "TO":
                    line.append("TO")
                elif benchmark["Time (wall)"] == "ERR":
                    line.append("TO")
                else:
                    line.append(float(benchmark["Time (wall)"]))
    for val in methods:
        for benchmark in benchmarks:
            if benchmark[args.comp_field] == val:
                if benchmark["Regions"] in ["ERR", "TO"]:
                    line.append("TO")
                else:
                    line.append(int(benchmark["Regions"]))
                break
    output_table.append(line)

output_table = sorted(output_table, key=lambda x: (x[0], x[1], x[2], -float(x[3])))


if args.avg_slowdown:
    slowdowns = []
    slowdowns_with_names = []
    for row in output_table:
        time_a = row[5]
        time_b = row[6]
        # We deal with this manually
        if time_a == "TO" or time_b == "TO":
            if time_a != time_b:
                print("TO mismatch", row)
        else:
            slowdown = time_a / time_b
            slowdowns.append(slowdown)
            slowdowns_with_names.append((slowdown, row[0], time_a, time_b))
    print("Average slowdown:", sum(slowdowns) / len(slowdowns))
    print("Standard deviation:", np.std(slowdowns))
    slowdowns_with_names = sorted(slowdowns_with_names, key=lambda x: x[0])
    print(f"Slowest on {slowdowns_with_names[-1][1]}: {slowdowns_with_names[-1][0]}x slower ({slowdowns_with_names[-1][2]} vs {slowdowns_with_names[-1][3]})")
    print(f"Fastest on {slowdowns_with_names[0][1]}: {1 / slowdowns_with_names[0][0]}x faster ({slowdowns_with_names[0][2]} vs {slowdowns_with_names[0][3]})")
else:
    header = """
    \\toprule
    Model & Const & $\\delta$ & $\\varepsilon$ & Prop & \\multicolumn{2}{c}{Time (s)} & \\multicolumn{2}{c}{Regions} \\\\
    \\cmidrule(ll){6-7} \\cmidrule(ll){8-9}
    & & & & & nobig & big & nobig & big \\\\
    \\midrule
    """

    tabulate.LATEX_BOOKTABS_ESCAPE_RULES = {}
    print(tabulate.tabulate(output_table, tablefmt="latex_booktabs").replace("\\toprule", header).replace("tabular", "longtable").replace("\\$", "$").replace("\\textbackslash{}", "\\"))
